'use strict';

var _ = require('lodash'),
  request = require('request-promise');

module.exports = scraper;

function scraper (options){
  var Client;

  /**
   * Generate a new instance of the scraper class.
   *
   * @param {Object} options Options that can be forwarded to the API.
   * @return {Object} Returns this instance of the scraper class.
   */
  Client = function(options){

    // Set options for use in all requests
    this.options = _.extend({
      cacheOk: true,
      version: '1.0'
    }, options || {});

    // Will need to implement this soon
    if(!this.options.appId){
      throw 'appId must be supplied when making requests to the API.'
    }

    return this;
  };

  /**
   * Generate the URL Required to complete the request.
   *
   * @param {string} url The URL that should be scraped.
   * @param {Object} options Options that can be forwarded to the API
   * @return {Object} Options Processed.
   */
  Client.prototype._getSiteInfoUrl = function(url, options){
    var proto = options.appId ? 'https' : 'http';

    var baseUrl = proto + '://localhost/api/' + options.version + '/scrape/?url=' + encodeURIComponent(url);

    return baseUrl;
  };

  /**
   * Generate the Query Params required to complete the Request
   *
   * @param {Object} options Options that can be forwarded to the API
   * @return {Object} Options Processed.
   */
  Client.prototype._getSiteInfoQueryParams = function(options){
    var queryStringValues = {};

    if(options.cacheOk === false){
      queryStringValues.cache_ok = 'false';
    }

    if(options.appId){
      queryStringValues.app_id = options.appId;
    }

    if(options.json){
      queryStringValues.json = options.json;
    }

    return queryStringValues;
  };

  /**
   * Connect to API and Request for only the body and the headers of the page.
   *
   * @param {String} url Website URL to Scrape
   * @param {Object} options Object list of the Options to pass to the API
   * @param {function} cb Callback to Provide the Result to the Request.
   * @return {Promise} Return from the Promise generated by Request
   */
  Client.prototype.getSiteData = function(url, options, cb){

    var opts = {};
    var callback;

    if(options && typeof(options) !== 'function'){
      // Set the Options if its NOT a function.
      opts = options;
    }
    else if(options && typeof(options) === 'function'){
      // Reassign "options" (really the callback) to be the callback
      //  as the user has NO options.
      callback = options;
    }

    // Set the Callback when its NOT a function.
    if(typeof(cb) === 'function'){
      callback = cb;
    }

    var requestOptions = _.extend(this.options, opts);

    var baseUrl = this._getSiteInfoUrl(url, requestOptions);
    var queryStringValues = this._getSiteInfoQueryParams(requestOptions);

    var params = {
      method: 'GET',
      uri: baseUrl,
      qs: queryStringValues,
      json: true,
      encoding: 'utf8'
    };

    return request(params)
      .then(function(results){
        if(callback){
          callback(null, results);
        }
        else{
          return results;
        }
      })
      .catch(function(err){
        if(callback){
          callback(err);
        }
        else{
          Promise.reject(err);
        }
      });
  };

  /**
   * Connect to API and Request for a Full page Render.
   *
   * @param {String} url Website URL to Scrape
   * @param {Object} options Object list of the Options to pass to the API
   * @param {function} cb Callback to Provide the Result to the Request.
   * @return {Promise} Return from the Promise generated by Request
   */
  Client.prototype.getSiteRender = function(url, options, cb){

    var opts = {};
    var callback;

    if(options && typeof(options) !== 'function'){
      opts = options;
    }
    else if(options && typeof(options) === 'function'){
      callback = options;
    }

    if(cb){
      callback = cb;
    }

    opts.full_render = true;

    return this.getSiteData(url, opts, callback);

  };

  return new Client(options);
};
